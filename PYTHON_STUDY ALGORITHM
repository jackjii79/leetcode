1 
suffix array:
the prefix of suffix array is the substring of the whole string
"banana" suffix array is ["banana","anana","nana","ana","na","a"]

2
rabin karp algo for substring match:
len_source, len_target = len(source), len(target)
        modulo = random.randint(1000000, 2000000)
        hash_source, hash_target, base = 0, 0, 26
        for idx in range(len_target):
            hash_target = ((ord(target[idx])-ord('a')) + base * hash_target) % modulo
            if hash_target < 0:
                hash_target += modulo
        max_base = 1
        for idx in range(len_target-1):
            max_base = (max_base * base) % modulo
        for idx in range(len_source):
            if idx >= len_target:
                hash_source = (hash_source - (ord(source[idx-len_target])-ord('a')) * max_base) % modulo
            hash_source = (ord(source[idx])-ord('a') + hash_source * base) % modulo
            if hash_source < 0:
                hash_source += modulo
            if idx >= len_target-1 and hash_source == hash_target:
                return idx-len_target+1
                
3 DFS for subsets II to deal with the duplicated cases:
def dfs_search(self, nums, st_idx, subsets, results):
        results.append(subsets[:])
        for idx in range(st_idx, len(nums)):
            if idx-1 >= 0 and nums[idx] == nums[idx-1] and idx > st_idx:#think about the situation [1,2',2''] 
            #when we have [2'] and [2''], how to avoid this ?
                continue
            self.dfs_search(nums, idx + 1, subsets+[nums[idx]], results) #make sure subsets+[nums[idx]] can 回溯 !
        return
        
4 search target in roated sorted array sample code:
while st <= end:
            middle = int((st + end) / 2)
            if A[middle] == target:
                return middle
            else:
                if A[middle] > A[end]: #case when more than half on the left is bigger increasing subarray
                    if A[middle] < target:
                        st = middle + 1
                    elif A[middle] > target and target > A[end]:
                        end = middle - 1
                    elif A[middle] > target and target <= A[end]:
                        st = middle + 1
                else: #case when more than half on the right is smaller increasing subarray
                    if A[middle] > target:
                        end = middle - 1
                    elif A[middle] < target and target <= A[end]:
                        st = middle + 1
                    elif A[middle] < target and target > A[end]:
                        end = middle - 1
        return -1
