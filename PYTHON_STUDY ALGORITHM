1 
suffix array:
the prefix of suffix array is the substring of the whole string
"banana" suffix array is ["banana","anana","nana","ana","na","a"]

2
rabin karp algo for substring match:
len_source, len_target = len(source), len(target)
        modulo = random.randint(1000000, 2000000)
        hash_source, hash_target, base = 0, 0, 26
        for idx in range(len_target):
            hash_target = ((ord(target[idx])-ord('a')) + base * hash_target) % modulo
            if hash_target < 0:
                hash_target += modulo
        max_base = 1
        for idx in range(len_target-1):
            max_base = (max_base * base) % modulo
        for idx in range(len_source):
            if idx >= len_target:
                hash_source = (hash_source - (ord(source[idx-len_target])-ord('a')) * max_base) % modulo
            hash_source = (ord(source[idx])-ord('a') + hash_source * base) % modulo
            if hash_source < 0:
                hash_source += modulo
            if idx >= len_target-1 and hash_source == hash_target:
                return idx-len_target+1
                
3 DFS for subsets II to deal with the duplicated cases:
def dfs_search(self, nums, st_idx, subsets, results):
        results.append(subsets[:])
        for idx in range(st_idx, len(nums)):
            if idx-1 >= 0 and nums[idx] == nums[idx-1] and idx > st_idx:#think about the situation [1,2',2''] 
            #when we have [2'] and [2''], how to avoid this ?
                continue
            self.dfs_search(nums, idx + 1, subsets+[nums[idx]], results) #make sure subsets+[nums[idx]] can 回溯 !
        return
        
4 rotated sorted array minimum sample code:
while st + 1 < end:
            mid = int((st + end) / 2)
            if nums[mid] == nums[end]: #we can remove end by not losing the minmum element !
                end -= 1
            elif nums[mid] > nums[end]: #more than half is bigger subarray on the left
                st = mid
            else: #more than half is smaller subarray on the right
                end = mid
        if nums[st] <= nums[end]:
            min_idx = st
        else:
            min_idx = end
            
  rotated sorted array target sample code:
  while st + 1 < end:
            middle = int((st + end) / 2)
            if A[middle] == target:
                return True
            elif A[middle] > A[end]: #more than half is bigger subarray on the left
                if A[middle] > target and A[st] <= target:
                    end = middle
                else:
                    st = middle
            elif A[middle] < A[end]: #more than half is smaller subarray on the right
                if A[middle] < target and target <= A[end]:
                    st = middle
                else:
                    end = middle
            elif A[middle] == A[end]:
                end -= 1
        return A[st] == target or A[end] == target

5 Two pointers algorithm:
1) how to remove duplicated elements in the solution set ?
ex: our result is a list of list and do not allow duplicated list element exists in our solution nested list
we should remove duplicated list as we progress the program instead of using set or check duplicated once we finished !!
problem 4sum:
numbers.sort()
        result = []
        for fir in range(len(numbers)-3):
            if fir != 0 and numbers[fir] == numbers[fir-1]: #skip duplicated
                continue
            for sec in range(fir+1, len(numbers)-2):
                if sec != fir+1 and numbers[sec] == numbers[sec-1]: #skip duplicated
                    continue
                third, fourth = sec+1, len(numbers)-1
                while third < fourth:
                    if numbers[fir]+numbers[sec]+numbers[third]+numbers[fourth] < target:
                        third += 1
                    elif numbers[fir]+numbers[sec]+numbers[third]+numbers[fourth] > target:
                        fourth -= 1
                    else:
                        result.append((numbers[fir],numbers[sec],numbers[third],numbers[fourth]))
                        while third+1 < fourth and numbers[third] == numbers[third+1]: #skip duplicated
                            third += 1
                        third += 1
                        while fourth-1 > third and numbers[fourth] == numbers[fourth-1]: #skip duplicated
                            fourth -= 1
                        fourth -= 1
        return result
