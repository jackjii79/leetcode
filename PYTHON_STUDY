python knowledge:
1 how to sort with multiple keys:
data.sort(key=lambda item: (item[1], item[0]), reverse=True)
here, item[1] is the primary key and item[0] is the secondary key
if we want to sort keys in different directions(increasing/decreasing) we can just use negative, like
data.sort(key=lambda item: (item[1], 0-item[0]), reverse=True) we sort item[1] in increasing and item[0] in decreasing if ties occur

2 ordereddict:
if raw_key not in self.hashtable.keys():
            self.hashtable[raw_key] = collections.OrderedDict() #we use ordereddict structure to store column key-value 
        self.hashtable[raw_key][column_key] = column_value
here we use ordereddict to store column_key and column_value pair, using ordereddict can make us easy to return output in order!!!
we can just do sth like: new_hash = collections.OrderedDict(sorted(self.hashtable[key].items())) where we can traverse new_hash
in order and output in order !!!

we can also sort values/keys in ordereddict:
>>> a
OrderedDict([(2, [3, 0]), (4, [3, 1]), (1, [1, 2])])
we show how to sort the first element of value as the primary key and the second element of value will be the secondary key
>>> a=collections.OrderedDict(sorted(a.items(),key=lambda item:(item[1][0],item[1][1]),reverse=True))
>>> a
OrderedDict([(4, [3, 1]), (2, [3, 0]), (1, [1, 2])])
how to sort their key:
a=collections.OrderedDict(sorted(a.items(),key=lambda item:item[0]))
how to sort their value(if value is not a list)
a=collections.OrderedDict(sorted(a.items(),key=lambda item:item[1]))

3 base convertion:
convert a string of char into a base 62 number:from higher bit to lower bit(left to right)
id = 0
for ch in string:
 id = 62 * id + ord(ch)
convert a base 62 number into a string of char:from lower bit to higher bit(right to left)
while number > 0:
 output_string = str(number%62) + output_string
 number /= 62
 
 4 while loop strick:
 1) when perform binary search in a while loop:
 mid = int((start+end)/2)
 if we update left/right boundary, like start = mid + 1 or end = mid - 1 then the while condition is while start <= end;
 if we update left/right boundary, like start = mid+1 or end = mid then the while condition is while start < end.
 what we want to find is the biggest element that smaller than target, return start-1 
 
 Another equivalent form:
 while start + 1 < end:
  mid = start + (end-start)/2
  if mid > target:
   end = mid
  else:
   start = mid
 return start



